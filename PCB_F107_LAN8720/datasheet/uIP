Динамическое выделение памяти не используется, используется одиночный глобальный буфер (на один пакет) и таблица состояния соединения.
Интерфейсы двух типов - протосокеты (сокет подобный сокету BSD) и RAW IP
В случае с RAW IP есть единственная функция UIP_APPCALL(), которая вызывается в ответ на любые события, также есть макросы, с помощью которых можно определеить какое событие произошло.
кратко по делу:
- прием данных uip_newdata() возвращает 1 если данные пришли, uip_datalen() - объем принятых данных
- соединение, при вызове приложения глобальная переменная uip_conn указывает на структуру текущгего обрабатваемого соединения (чтобы определить какое)
- uip может отправить не все данны за раз (размеры буферов могут бтыть слишком маленькие), проверять количество отправленных данных через uip_mss()
- отправка данных осущесвляется через uip_send(указатель, размер), повторно вызвать нельзя
- закрытие соединения, для чистого закрытия использовать uip_close(), для прерывания uip_abort()
- ошибки можно отслеживать с помощью uip_aborted() (если соединение разорвано удаленным компом) и uip_timedout() (если таймаут истек) 
- периодический опрос осуществляется для двух целей: - отслеживание мертвых соединений, - для инициализации отправки данных удаленным хостом (uip ждет опроса для того чтобы отправить данные), осуществляется функцией uip_poll()
- прослушиваемые порты, 

*****Структурированный подход к разработке веб-приложения**************************
Все происходит внутри функции uip_appcall(), там нужно проверять текущее состояние TCP/IP стека и в соответствии с ним чего то там делать. Состояние стека опрашивается через следующие функции:
uip_aborted() - разорвано ли соединение
uip_acked() - подтверждены ли переданные данные
uip_closed() - закрыто ли соединение на дальнем конце
uip_connected() - произведено ли соединение только что
uip_newdata() - есть ли новые данные?
uip_poll() - произошел ли периодический опрос?
uip_rexmit() - нужно ли по новой отправить ранее посланные данные?
uip_timedout() - истек ли таймаут на соединении?


*****HTTP итить его в корень*********************
Создан в год моего рождения (1992)
HTTP для передачи гипертекста между клиентом (веб-браузером) и веб-сервером (спасибо кэп).
Как правило используется 80й порт (если не указано иное).
Для https используется порт 433
Стартовая строка запроса: <Метод> <URI> <HTTP/Версия>

Основной объект в HTTP это ресурс, который указывается в URI клиента. Обычно это файл, хранящийся на веб сервере, но может быть и абстрактный объект).
Обмен сообщениями по схеме запрос-ответ, промежуточное состояние между парами запрос-ответ отсутствует, не нужно хранить никаких данных о состоянии протокола.
Протокол текстовый, но в заголовке имеется возможность указать способ представления данных (кодировка, язык, формат).
Каждое сообщение состоит из:
1. стартовая строка (определяет тип сообщения)
2. заголовки (характеризует тело сообщения)
3. Тело сообщения - данные сообщения непосредственно.

Стартовая строка запроса состоит из:
- метод (GET, POST, и тому подобное (обязательно большими буквами))
- URI - путь до запрашиваемого документа
- HNNP/Версия - версия http (текущая 1.1)
Стартовая строка ответа:
- версия
- Код состояния (Status code) - по коду состояния определяют наличие или отсутствие ошибок, содержание сообщения и поведение клиента
- Пояснение (Reason phrase) - текстовое пояснение к коду состояния (предназначено для людей, необязательное поле)

методы:
Обязательны GET и HEAD, остальные опциональны, еще широко используется POST.

GET - запрос содержимого ресурса, а еще с помощью этого метода сейчас люди творят много разной херни бесполезной (например можно запускать процессы (какие? зачем? почему именно с помощью этого метода?))
можно передавать параметры выплнения запроса в URI после знака ? (GET /path/resourse/?param1=value1&param2=value2 HTTP/1.1). Есть еще частичныйй GET и условный GET. Частичный применяется для передачи части запрашиваемого контента (с указанным в заголовке байтовым диапазоном). Условный GET запрашивает данные только при уусловии того что они были изменены после определенного момента, если данные не изменялись, то они не передаются (метод призван уменьшить нагрузку на сеть).

HEAD - почти как GET, но с отсутствующим телом ответа, предназначен для извлечения метаданных ресурса, проверки его наличия и проверки на изменения ресурса (по изменению метаданных) 

POST - отправка данных от клиента серверу, данные содержатся в самом запросе (отправка файлов, комментов на фоточки)

PUT - загрузка на указанный в URI ресурс (авторитарнее чем POST)
PATCH - PUT для фрагмента
DELETE - удалить указанный ресурс
А еще их очень много, нефиг всех перечислять

Заголовки:
Содержат различные свойства. Формат следующий:
имя: значение1, ..., значениеN
Бывают основные заголовки, заголовки запроса, ответа и сущности (описывают каждую сущность сообщения). 


Коды состояния:
По коду состояния клиент узнает о результатах его запроса и определяет какие ему действия предпринимать дальше.
- клиент может не знать о всех кодах состояния, но он обязан отреагировать на класс кода (первая его цифра)
Классы кодов и некоторые из них:
1 - информационные (информируют о процессе передачи данных, например о том, что на обработку понадобится длительное время (102))
2 - успех (двойка это не успех, а скорее наоборот, но в HTTP все не так) - сообщяют об успешной обработке запроса (успешно переданных, успешно частично переданных, или успешно обнаруженным отсутствием необходимости передачи данных ну и еще много всего, самый распространенный код - 200 OK)
3 - перенаправление - сообщает клиенту, что для успешного выполнения операции нужно сделать другой запрос. Иначе говоря - ищи в другом месте (в ответе помимо кода должен содержаться URI по которому находится это самое другое место).
4 - ошибка со стороны клиента (используется когда для получения запрашиваемых данных требуется аутентификация(401), слишком длинный (или вообще какой то не такой или не доступный в данном конкретном случае) заголовок(406, 431), URL, метод (405). Если для доступа к данным нужно заплатить или нарушить закон (402, 451, 403). Или в том случае, если запрошенных данных просто нет (404).
418 - I'm a teapot - код состояния навсе случаи жизни
5 - Ошибка сервера - передается в случае неудачно выполненной операции по вине сервера. Используется если сервер ничего не знает о запрашиваемом методе(501), временно не может обработать запрос (по причине перегрузки например, 503), если сервер не сервер а прокси сервер и origin server ему не отвечает (504), ну или просто серверу лень отвечать, тогда он шлет код состояния 500 (Internal server error) что в переводе означает "отъебись"

Тело сообщения:
содержит тело объекта связаного с запросом или ответом, тело сообщения зачастую является и телом объекта, если не применяется шифрование. Тело сообщения и тело объекта отсутствует в тех случаях, если метод запроса и код состояния не предусматривают тела сообщения. Но если тело сообщение предусмотрено, то оно обязательно должно быть, даже если оно имеет нулевую длину.


В обмене пакетами участвуют:
Серверы (origin server) - отвечают на запросы, хранят и предоставляют информацию
Клиенты - отправляют запросы (потребители)
Прокси (не origin но все же сервер)



libhttpd





























чего нету:
- полноценной реализации интерфейса стека (т.к. он требует использования функционала операционной системы)
- не используется какая то фигня с мультикастами, но она редко используется (хрен знает что это ну эт наверно занчит что она и не нужна)
- пересборка пакетов есть, и рассчитана только на один пакет
- в ICMP реализовано только эхо, реализации Path MTU discovery или сообщений перенаправления ICMP там нет, (т.к. это используется только для улучшения качества связи, и вовсе не обязательно)
- реализации скользящего окна TCP (она необязательна, и к тому же требует буферизации и кучи 32 разрядных операций)
- 
