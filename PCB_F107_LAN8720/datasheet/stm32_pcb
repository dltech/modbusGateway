Питание:
- напряжение питания от 2 до 3,6 В, которое потом понижается до 1,8 внутренним регулятором, но если используется АЦП, то напряжение питание ограничено диапазоном 2,4 - 3,6 В
- для часов (RTC) предусмотрено питание от батарейки Vbat, если батарейка не используется, то Vbat рекомендуется коннектить к Vdd.
- к каждой лапе Vdd по разделительному конденсатору на 100нФ + общий кондер не менее 4.7мкФ (10мкФ типовая емкость), для лапы Vdda обязательно 100нФ + 1мкФ, при этом 100нФ на лапу Vbat (если на подключена к общему питанию)
- Vref можно коннектить к Vdda
Ресет:
- лапа NRST (ресет) не требует никаких дополнительных схем (буит работать хорошо даже если будет висеть в воздухе), но для совсем полной уверенности можно поставить кондер на 100нФ, но при этом увеличится энергопотребление схемы, для ее снижения можно поставить 10нФ. Для нажатия на ресет нужно ебануть этой лапой об землю.
Тактирование:
- HSE для подключения внешнего генератора (хавает любые прямоугольные, синусоидальные, треугольные импульсы со скважностью около 50%) подключить к лапе OSC_IN, OSC_OUT оставить висеть в возухе (HI-Z)
- кварц к HSE подключается как можно ближе (чтобы было как можно меньше помех), есмкости и сопротивление подбираются для каждого кварца индивилуально, оценочное значение емкости пинов и платы составляет 10пФ)
- К LSE можно подключать внешний генератор так же как и к HSE, частота до 1мГц. Кварц подключается так же, частота кварца - 32768Гц
Конфигурация загрузки:
- лапы boot на схеме подключены через резисторы по 10кОм 
	конфиг следущий: BOOT1 BOOT0
						*	0		- flash память
						0	1		- системная память (то где находится ботлоадер)
						1	1		- встроенная SRAM
- к слову, ботлоадер на устройствах connectivity line может прохиваться не только по USART (как на всех остальных линейках), а еще и через CAN и USB - ну это если тактирование нормальное есть (от кварца или внешнего генератора)
Отладочные интерфейсы:
- ну про то что на ентих контроллерах есть житах и SW я говорить не буду
- а еще эти пины можно отключить (можно все, можно частично), вернув им состояние обычных портов ввода/вывода (по умолчанию включены отладочные интерфейсы)
- стандарт требует использовать резисторы подтяжи, но они и так уже есть встроеннные, потому они не нужны
Общие рекомендации:
- по хорошему нужно разводить этот контроллер на какой нибудь четырехслойке (чтоб один слой для земли и один для питания), но, ежели вы делаете нищебродский девайс, попробуйте хотя бы подвести землю и питание нормально.
- по хорошему, мощные, слаботочные и цифровые куски схемы нужно распинать по разным углам (а то они в одной общей куче будут друг другу помехи создавать)
- следует избегать петель земли и питания (т.к. они начинают работать как антенны), земли различных блоков нужно кучковать отдельно и соединять вместе в одной точке. Куски не занятые электронными компонентами лучше заливать (или засыпать) землей. 
- еще землю и питание лучше протащить параллельно друг другу
- нужно обратить особое внимание на сигналы тактирования и прерывания (те порты, мгновенное возмущение на которых приведет к ошибкам)
- не стоит забывать выключать и прижимать к земле/питанию неиспользуемые порты



LAN8720A
- есть auto-negoation и auto-MDIX так что можно втыкать любые кабели и использовать на любых скоростях
- для конфигурации сего девайса есть регнистры те что определены разработчиком железа и свои регистры, но можно и без них (задать конфиг лапками)
- внутренний регулятор на 1,2 В есть, но он не слишком эффективен, можно использовать внешний


100BASE-TX Transmit
1. данные передаются через лапы TXD по тактам REFCLK в блок RMII, при этом TXEN сигнализирует о наличии таковых
2. дальше данные (состоящие из 4х битных слов или ниблов) передаются в 4B/5B encoder, он преобразует ниблы в 5-битные слова (code groups), при этом 16 из них соответствуют 16 возможным ниблам, а другие 16 несут служебную информацию либо не используются вовсе.
3. дальше данные поступаюбт в scrambler, после которого сигнал с данными становится равномерно распределенным по всей ширине полосы канала, что уменьшает ЭМИ кабеля. Зерно scramblerа это физический адрес устройства PHYAD. Также в scrambler встроен блок PISO (Parallel In Serial Out).
4. Дальше данные преобразуются в NRZI, а потом в MLT-3 код. MLT-3 - трехуровневй код, где изменение логического уровня представляется "1", а его неизменность - "0"
5. и наконец данные поступают в аналоговый передатчик (драйвер) из которого выходят на лапы TXN и TXP.
6. ну и дальше там катушки, разъем, кабель и все такое

А еще там где то затерялся PLL, который тактируется от SYSCLK и выдает 125 МГц чтобы тактировать передатчик

100BASE-TX Receive
1. MLT-3 приходит с трансформаторов на лапы RXN и RXP, дальше идет на АЦП, в котором оцифровывается с частотой дискретизации 125МГц и 6-битовым квантованием.
2. дальше цифровой сигнал поступает на DSP, там компенсируется искажение фазы и амплитуды. Также DSP контролирует усиление АЦП чтобы подобрать оптимальное, использующее весь динамический диапазон, а еще он подкручивает фазу PLL тактирующего АЦП.
3. Далее восстановленные MLT-3 данные поступают на MLT-3 MRZI декодер
4. дальше данные поступают на descrambler со встроенным SIPO, он выполняет операцию, обратную scramblingу, при этом ключ вычисляется автоматически. Имеется блок с окном в 4000 выборок, в котором отыскиваются IDLE коды, по которым вычисляется ключ. Если IDLE символы найти не удалось, выдается ошибка и descrambling не осуществляется
5. дальше осуществляется выравнивание данных (чтобы выделить пятибайтовые слова и начало пакета), осуществляется оно по Start-of-Stream Detirmier (SSD)
6. потом 5B слова преобразуются в 4 битные и отправляются на лапы RXD, такое служебное слово как SSD преобразуется в последовательность 0101 0101. Передача пакета по MII интерфейсу осуществляется так: при успешном descramblingе и выравнивании, сразу же после обнаружения слова SSD включается сигнал receive data valid (RXDV), по лапам сначала передается 01010101, после чего идут данные, далее после обнаружения слова End-of-Stream Detirmier (ESD) приемник прекращает предавать данные по MII и отрубает сигналы carrier sense и RXDV
- если при приеме данных обнаружена ошибка, то устанавливается соответствующий сигнал (RXER), и по лапам RXD передается код ошибки
- данные считываются контроллеров по восходящему фронту REF_CLK, при этом приемником они выплевываются по спадающему фронту.

10BASE-T Transmit
1. Тут все проще, все так же даннные идут на лапы TXD по тактам REF_CLK (которая уже не 50, а 2,5МГц), при включенном TXEN. Ежели TXEN отключено, то тодда на TXD лучше держать нули (хрень какая то там), а еще для обратной совместимости он в полудуплексном режиме передаваемые данные выдает на лапы RXD, но они MAC смущать не должны, т.к. COL сигнал не включается в этот момент.
2. NRZI для 4-х битовых ниблов, как есть
3. Манчестеркое кодирование (тактируктся от PLL 20 МГц), а если данные в кодер не поступают, он выдает Normal Link Pulses (NLPs)
4. Потом сигнал идет через драйвер, где обрабатывается фильтом
5. Как обычно TXN, TXP, трансы, разъемы, витуха

10BASE-T Receive
1. Прийдя от трансформаторов и разъемов сигнал приходит в аналоговый блок шумоподавления, представляющий из себя набор компараторов, которые отражают дифференциальные сидналы напряжением ниже 300 мВ, и распознают сигналы выше 585 мВ
2. Манчестерский код обратно в NRZI
3. NRZI догадайтесь куда? также декодер распознает Normal Link Pulses (NLPs)
4. RXD, RXEN, REF_CLK...
- еще есть штука, которая прерывает передачу данных при привышении максимально допустимого размера пакета (Jabber detection)

Auto negotiation
Стандартная процедура, определяет оптимальное соединения для получившейся пары связи. Выполняется чисто на физическом уровне (MAC даже о ней не знает). Работает в автоматическом режиме, но можно чего то в ней поконфигурировать и проследить то что она натворила через соответствующие регистры.
Включается в пяти случаях: аппаратный сброс, программный сброс, сброс по питанию, сброс соединения, после установки определенного бита в регистре
При включении этого режима отправляется специальная последовательность (чем то похожая на FLP), в которой содержатся все возможные режимы работы сети: 100M Full duplex, 100M Half duplex, 10M Full duplex, 10M Half duplex, после обмена последовательностями и подтверждениями, контроллеры выбирают наилучший режим из возможных (если в переданных данных была ошибка, эта штука запускается по новой).
Возможные режимы можно задать специальными конфигурационными лапками, либо через регистр.
Еще его можно включить вручную, тогда устройство прекратит передачу данных на определенный промежуток времени, чем вызовет ответ устройства на другом конце. 

Parallel detection
Опять штука для совместимости с чем то древним. Суть. Микра сама определяет режим связи (полудуплексный) в случае если другой конец не отвечает на auto negotation последовательности.
- А еще тут есть CSMA/CD для работы в полудуплексном режиме и определения коллизий (о их наличии можно посмотреть в регистре)

HP Auto-MDIX
Микра может сама определить какие пины RX, какие TX (кроссовый или прямой кабель), сама определяет, сама меняет их местами. Можно ипользовать эту фишку при разводке ПП.

RMII интерфейс
Основные лапы:
- TXD[1:0] - передача данных
- TXEN - передача данных включена
- RXD[1:0] - прием данных
- RXER - опционально, ошибка приема данных
- CRS_DV - Carrier Sense/Receive Data Valid врубается тогда когда устройство почуяло сигнал на RXD лапах, вырубется когда сигнала нет, но только на первых полуниблах (таким образом при 50 МГц этот сигнал тактируется 25ю)
- REF_CLK - частота сети, от нее все тактируется

Serial Managerment Interface (SMI)
Предназначен для контроля приемопередатчика и отслеживания его состояния микроконтроллером
Лапы две: MDIO и MDC ввод-вывод данных и тактирование, минимальное время на один цикл 400 нс

Прерывания:
Этот блок не является частью стандарта IEEE802.3. Есть два режима основной и альтернативный, в обеих режимах лапа nINT переключается из лог 1 в лог 0 сразу после установки бита соответствующего маске. Отличаются они условием, при котором включенное прерывание будет сбрасываться. В основном режиме прерывавние сбрасывается как правило при считывания регистра флагов или регистра, относящегося к этому событию.  
В альтернативном режиме прерывание не сбрасывается до тех пор пока не запишут единицу в флаг этого прерывания, после чего происходит повторная проверка условия, и если оно не выполняется, тогда прерывание обнуляется. Так же прерывание обнуляется и после обнуления соответствующего бита в маске прерываний.
А еще там бит ENERGYON всегда нужно будет чистить, иначе он будет дергать лапу прерывания постоянно.

Configuration straps (хрен пойми как это перевести):
Короче какие то там лапы, предназначенные для конфигурации. Считывание лап и применение соответствующих настроек происходит после аппаратного сброса (программный не катит). Все эти настройки можно поменять на любые другие через регистры.
Перечисление битов:
- PHYAD[0] - по умолчанию 0, конфигурирует физический адрес устройства, можно выставить нолдь или единицу, а если надо больше, тодга, пользуясь уже установленном с помощью лапы адресом, можно его поменять через запись регистра по SMI. 
Разные физические адреса нужены для того, чтобы различать устройства, управляемые одним итем же контроллером, а также для того, чтобы у scramblerов были разные зерна и сигналы равномерно распределялись по спектру, не создавая помех.
- MODE[2:0] - режим работы приемопередатчика, 100 или 10 Мбит, дуплексный или полудуплексный режим, ну и все в этом духе, 111 - самая нормальная конфигурация (в этом слдучае режим работы определяется автоматически)
- REGOFF - при подктяжке к VDD2A отключает внутренний регулятор напряжения (по умолчанию лапа притянута к земле и регулятор вкл). Дело в том что внутри стоит линейный стабилизатор, а между тем, можно запитать приемопередатчик от импульсника (через лапу VDDCR), с помошью чего уменьшить энергопотребление. И да, никакими регистрами это барахло не переключить.
- nINTSEL - все дело в том, что лапа одна на прерывания и на конфигурацию тактирования MAC блока. Если подать 1 (или воспользоваться встроенной подтяжкой к питанию), то nINT/REFCLKO будет работать как лапа  прерывания, при этом подразумевается что MAC тактируется от внешнего генератора. А если подтянуть nINTSEL к земле, то прерывания работать перестанут, а nINT/REFCLKO будет выдавать 50МГц для тактирования MAC от подключенного к микросхеме 25МГц кварца.
- лучше конфигурационные лапы подтягивать к VDDIO чем к VDDA за исключением REGOFF и nINTSEL

Светодиоды:
LED1 светит при активном соединении и мыргает когда есть какой то сигнал на линии (CRS).
Выходы на светодиоды совмещены с REGOFF и nINTSEL, и их схемы надо согласовывать (они нарисованы в даташите, достаточно взять и посмотреть 3.10 и 3.11).

Режимы энергосбережения:
Их два. В первом режиме (основном) выключается все за исключением интерфейса управления (SMI).
Во втором (Energy Detect Power-Down) отключается практически вся микросхема до тех пор, пока не обнаружится какой либо сигнал на витухе. Но после обнаружения сигнала, премопередатчик включается, и вызывается прерывание ENERGYON (правда с небольшой задержкой, так что первый пакет можно потерять).

Режим изоляции:
Есть режим, при котором микросхема может обрабатывать транзакции, но при этом не реагирует на происходящее на RMII интерфейсе. Режим нужен для подключение нескольких приемопередатчиков к одной линии.

Сбросы:
Есть программный и аппаратный, оба сбрасывают все регистры за исключением NASR (знать бы что это). Аппаратный сброс активируется прижатием лапы к земле, программный установлением соответсвующего бита в регистре, программный сброс длится 0,5 с, аппаратный - хз сколько.

Carrier sense (CRS)
Стандартная штука, которая определяет наличие сигнала на линии приемника, принцип работы объяснять лениво.

Link Integrity test
Так же стандартная штуковина, которая поределяет наличие соединения по нормальности цифрового сигнала и результату работы auto-negotiation.

Петля:
Петлю можно осуществить следующими способами:
- Near-end Loopback - петля на блдижнем конце, данные, которые передаются на физический уровень тут же возвращаются обратно. Аналоговая часть не задействована, активируется режим через регистры.
- Far Loopback - петля на дальнем конце, работают аналоговые цепи, на цифровом блоке сигнал закольцован, MAC уровень изолирован.
- Connector loopback - нет ничего криминального в том чтобы замкнуть RX на TX кабелем.

На каждое питание надо не забыть поставить по кондеру от помех + кондер на побольше на VDDIO, и 1мкФ + 470пФ на VDDCR (даже если он запитан от внутреннего регулятора). На подтяжку RX и TX желательно бы поставить катушечку, но можно и забить на это дело.




STM32 MAC.
